/* eslint-disable react-hooks/rules-of-hooks */
import { test as base } from '@playwright/test';
import { PrismaClient } from '../../src/generated/prisma';
import { execSync } from 'child_process';
import { existsSync, mkdirSync, unlinkSync } from 'fs';
import { faker } from '@faker-js/faker';

// Test configuration - use a unique path for each test run
const TEST_DB_PATH = `e2e/test-${Date.now()}-${Math.random()
  .toString(36)
  .substring(7)}.db`;
const TEST_DATABASE_URL = `file:./${TEST_DB_PATH}`;

export interface DatabaseFixture {
  database: PrismaClient;
  seedTestData: () => Promise<void>;
  cleanupDatabase: () => Promise<void>;
}

// Reset database and apply schema
async function resetDatabase() {
  try {
    // Ensure e2e directory exists
    if (!existsSync('e2e')) {
      mkdirSync('e2e', { recursive: true });
    }

    // Remove existing test database if it exists
    if (existsSync(TEST_DB_PATH)) {
      unlinkSync(TEST_DB_PATH);
    }

    // Set environment for test database
    process.env.DATABASE_URL = TEST_DATABASE_URL;

    // Reset the test database (client should already be generated by webServer)
    execSync('bunx prisma db push --force-reset', {
      stdio: 'pipe',
      env: { ...process.env, DATABASE_URL: TEST_DATABASE_URL },
    });

    console.log('Test database reset completed');
  } catch (error) {
    console.error('Database reset failed:', error);
    throw error;
  }
}

// Seed test database with fake data
async function seedTestData(prisma: PrismaClient) {
  try {
    // Clear existing data
    await prisma.mediaItem.deleteMany();
    await prisma.appSettings.deleteMany();

    // Create test media items - Movies
    const testMovies = Array.from({ length: 10 }, (_, i) => ({
      title: faker.lorem.words(3),
      type: 'MOVIE',
      year: faker.date
        .between({ from: '1990-01-01', to: '2023-12-31' })
        .getFullYear(),
      tmdbId: faker.number.int({ min: 1000, max: 999999 }),
      imdbId: `tt${faker.number.int({ min: 1000000, max: 9999999 })}`,
      lastWatched: faker.helpers.maybe(() => faker.date.recent()) || null,
      watchCount: faker.number.int({ min: 0, max: 10 }),
      embyId: `emby-movie-${i + 1}`,
      radarrId: faker.number.int({ min: 1, max: 1000 }),
      mediaPath: `/media/movies/${faker.lorem
        .words(2)
        .replace(/\s/g, '-')}.mkv`,
      parentFolder: '/media/movies',
      sizeOnDisk: faker.number.bigInt({
        min: BigInt(1000000000),
        max: BigInt(5000000000),
      }),
      dateAdded: faker.date.recent({ days: 30 }),
      source: 'radarr',
      quality: faker.helpers.arrayElement(['720p', '1080p', '4K']),
      qualityScore: faker.number.int({ min: 1, max: 10 }),
      monitored: faker.datatype.boolean(),
      imdbRating: faker.number.float({ min: 1, max: 10, fractionDigits: 1 }),
      tmdbRating: faker.number.float({ min: 1, max: 10, fractionDigits: 1 }),
      playProgress: faker.number.int({ min: 0, max: 100 }),
      fullyWatched: faker.datatype.boolean(),
      runtime: faker.number.int({ min: 90, max: 180 }),
      sizePerHour: faker.number.float({ min: 1, max: 10, fractionDigits: 2 }),
      genres: JSON.stringify([
        faker.helpers.arrayElement([
          'Action',
          'Comedy',
          'Drama',
          'Horror',
          'Sci-Fi',
        ]),
      ]),
      overview: faker.lorem.paragraph(),
      deletionScore: faker.number.float({
        min: 0,
        max: 100,
        fractionDigits: 2,
      }),
    }));

    // Create test media items - TV Series
    const testSeries = Array.from({ length: 5 }, (_, i) => ({
      title: faker.lorem.words(2),
      type: 'SERIES',
      year: faker.date
        .between({ from: '2000-01-01', to: '2023-12-31' })
        .getFullYear(),
      tmdbId: faker.number.int({ min: 1000, max: 999999 }),
      imdbId: `tt${faker.number.int({ min: 1000000, max: 9999999 })}`,
      lastWatched: faker.helpers.maybe(() => faker.date.recent()) || null,
      watchCount: faker.number.int({ min: 0, max: 50 }),
      embyId: `emby-series-${i + 1}`,
      sonarrId: faker.number.int({ min: 1, max: 1000 }),
      mediaPath: `/media/tv/${faker.lorem.words(2).replace(/\s/g, '-')}/`,
      parentFolder: '/media/tv',
      sizeOnDisk: faker.number.bigInt({
        min: BigInt(5000000000),
        max: BigInt(20000000000),
      }),
      dateAdded: faker.date.recent({ days: 30 }),
      source: 'sonarr',
      quality: faker.helpers.arrayElement(['720p', '1080p', '4K']),
      qualityScore: faker.number.int({ min: 1, max: 10 }),
      episodesOnDisk: faker.number.int({ min: 1, max: 100 }),
      totalEpisodes: faker.number.int({ min: 10, max: 200 }),
      seasonCount: faker.number.int({ min: 1, max: 10 }),
      completionPercentage: faker.number.int({ min: 10, max: 100 }),
      monitored: faker.datatype.boolean(),
      imdbRating: faker.number.float({ min: 1, max: 10, fractionDigits: 1 }),
      tmdbRating: faker.number.float({ min: 1, max: 10, fractionDigits: 1 }),
      playProgress: faker.number.int({ min: 0, max: 100 }),
      fullyWatched: faker.datatype.boolean(),
      runtime: faker.number.int({ min: 20, max: 60 }),
      sizePerHour: faker.number.float({ min: 0.5, max: 3, fractionDigits: 2 }),
      genres: JSON.stringify([
        faker.helpers.arrayElement([
          'Drama',
          'Comedy',
          'Thriller',
          'Documentary',
        ]),
      ]),
      overview: faker.lorem.paragraph(),
      deletionScore: faker.number.float({
        min: 0,
        max: 100,
        fractionDigits: 2,
      }),
    }));

    // Insert all test media items
    await prisma.mediaItem.createMany({
      data: [...testMovies, ...testSeries],
    });

    // Create test app settings including instance configurations
    const appSettingsData = [
      // Deletion score settings
      {
        key: 'deletion_score_weight_play_count',
        value: '0.3',
        description: 'Weight for play count in deletion score calculation',
      },
      {
        key: 'deletion_score_weight_last_watched',
        value: '0.4',
        description:
          'Weight for last watched time in deletion score calculation',
      },
      {
        key: 'deletion_score_weight_file_size',
        value: '0.2',
        description: 'Weight for file size in deletion score calculation',
      },
      {
        key: 'deletion_score_weight_rating',
        value: '0.1',
        description: 'Weight for rating in deletion score calculation',
      },
      {
        key: 'media_processing_batch_size',
        value: '100',
        description: 'Batch size for media processing operations',
      },

      // Emby instance configuration
      {
        key: 'emby-name',
        value: 'Test Emby Server',
        description: 'Emby server name',
      },
      {
        key: 'emby-url',
        value: 'http://localhost:3000/api/mock/emby',
        description: 'Emby server URL',
      },
      {
        key: 'emby-apiKey',
        value: 'test-emby-api-key',
        description: 'Emby API key',
      },
      {
        key: 'emby-userId',
        value: 'test-user-id',
        description: 'Emby user ID',
      },
      {
        key: 'emby-enabled',
        value: 'true',
        description: 'Emby server enabled status',
      },
      {
        key: 'emby-selectedFolders',
        value: JSON.stringify(['/movies', '/tv']),
        description: 'Emby selected folders',
      },

      // Sonarr instance configuration
      {
        key: 'sonarr-test-name',
        value: 'Test Sonarr Server',
        description: 'Sonarr server name',
      },
      {
        key: 'sonarr-test-url',
        value: 'http://localhost:3000/api/mock/sonarr',
        description: 'Sonarr server URL',
      },
      {
        key: 'sonarr-test-apiKey',
        value: 'test-sonarr-api-key',
        description: 'Sonarr API key',
      },
      {
        key: 'sonarr-test-enabled',
        value: 'true',
        description: 'Sonarr server enabled status',
      },
      {
        key: 'sonarr-test-selectedFolders',
        value: JSON.stringify(['/tv']),
        description: 'Sonarr selected folders',
      },

      // Radarr instance configuration
      {
        key: 'radarr-test-name',
        value: 'Test Radarr Server',
        description: 'Radarr server name',
      },
      {
        key: 'radarr-test-url',
        value: 'http://localhost:3000/api/mock/radarr',
        description: 'Radarr server URL',
      },
      {
        key: 'radarr-test-apiKey',
        value: 'test-radarr-api-key',
        description: 'Radarr API key',
      },
      {
        key: 'radarr-test-enabled',
        value: 'true',
        description: 'Radarr server enabled status',
      },
      {
        key: 'radarr-test-selectedFolders',
        value: JSON.stringify(['/movies']),
        description: 'Radarr selected folders',
      },
    ];

    await prisma.appSettings.createMany({
      data: appSettingsData,
    });

    console.log('Test data seeded successfully');
  } catch (error) {
    console.error('Test data seeding failed:', error);
    throw error;
  }
}

// Cleanup database
async function cleanupDatabase(prisma: PrismaClient) {
  try {
    await prisma.mediaItem.deleteMany();
    await prisma.appSettings.deleteMany();

    console.log('Test database cleaned up');
  } catch (error) {
    console.error('Database cleanup failed:', error);
    throw error;
  }
}

// Extended test with database fixture
export const test = base.extend<DatabaseFixture>({
  database: async ({}, use: (arg: PrismaClient) => Promise<void>) => {
    // Setup: Reset and seed database
    await resetDatabase();

    const prisma = new PrismaClient({
      datasources: {
        db: {
          url: TEST_DATABASE_URL,
        },
      },
    });

    await seedTestData(prisma);

    // Use the fixture
    await use(prisma);

    // Teardown: Clean up and disconnect
    await cleanupDatabase(prisma);
    await prisma.$disconnect();
  },

  seedTestData: async (
    { database },
    use: (arg: () => Promise<void>) => Promise<void>
  ) => {
    await use(async () => {
      await seedTestData(database);
    });
  },

  cleanupDatabase: async (
    { database },
    use: (arg: () => Promise<void>) => Promise<void>
  ) => {
    await use(async () => {
      await cleanupDatabase(database);
    });
  },
});

export { expect } from '@playwright/test';
